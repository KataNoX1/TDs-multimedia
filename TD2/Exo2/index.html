<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>My first babylon.js app</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; }
      #renderCanvas { width: 100vw; height: 100vh; display: block; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>
    <script>
      // no accents in code
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true);

      const createScene = () => {
        const scene = new BABYLON.Scene(engine);

        //Camera
        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 5, Math.PI / 3, 6, new BABYLON.Vector3(0, 1, 0), scene);

        camera.upperBetaLimit = Math.PI * 0.5 - 0.01;
        camera.lowerRadiusLimit = 2;
        camera.upperRadiusLimit = 10;
        camera.wheelDeltaPercentage = 0.01;

        camera.attachControl(canvas, true);
        

        //LumiÃ¨re
        const ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
        ambientLight.intensity = 0.5;

        const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-1, -1.5, -1), scene);
        light.position = new BABYLON.Vector3(5, 7.5, 5);
        light.intensity = 0.8;

        const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
        shadowGenerator.useBlurExponentialShadowMap = true;


        //Cube
        const cube = BABYLON.MeshBuilder.CreateBox("box", { size: 1 }, scene);
        cube.position.y = 0.5;
        shadowGenerator.addShadowCaster(cube, true);
        cube.receiveShadows = true;

        cubeMaterial = new BABYLON.StandardMaterial("cubeMat");
        cubeMaterial.diffuseTexture = new BABYLON.Texture("default.png", scene);
        cube.material = cubeMaterial;


        //Phoque
        BABYLON.SceneLoader.ImportMeshAsync("", "./", "bagel_seal.glb", scene).then((res) => {
            const seal = res.meshes.find(m => m.name.includes("seal") && m instanceof BABYLON.Mesh) || res.meshes[0];
            seal.position = new BABYLON.Vector3(0, 1.23, 0);
            seal.rotation = BABYLON.Vector3.Zero();
            shadowGenerator.addShadowCaster(seal, true);
        });



        //Sol
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 10, height: 10 }, scene);
        ground.receiveShadows = true;

        return scene;
        };

        function isPhone() {
            return /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        let onPhone = isPhone();


        let hasOri = false;
        let A = 0, B = 0, G = 0;
        window.addEventListener("deviceorientation", (e) => {
            if (e.alpha == null) return;
                hasOri = true;
                A = e.alpha;
                B = e.beta;
                G = e.gamma;
        }, true);

        function applyPhoneToArcCam(cam) {
            const deg2rad = Math.PI / 180;
            const targetAlpha = A * deg2rad;
            const targetBeta  = (B + 90) * deg2rad;

            const minB = 0.15, maxB = Math.PI * 0.85;
            const clampedBeta = Math.min(Math.max(targetBeta, minB), maxB);

            const s = 0.15;
            cam.alpha = cam.alpha + (targetAlpha - cam.alpha) * s;
            cam.beta  = cam.beta  + (clampedBeta  - cam.beta ) * s;
        }

        const scene = createScene();

        engine.runRenderLoop(() => {
            if (onPhone) {
                applyPhoneToArcCam(scene.activeCamera);
            }
            
            scene.render();
        });

        window.addEventListener("resize", () => engine.resize());
    </script>
  </body>
</html>