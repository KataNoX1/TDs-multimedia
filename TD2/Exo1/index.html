<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
      html, body { margin: 0; padding: 0; overflow: hidden; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>
  </head>
  <body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const scene = new THREE.Scene();

        //Loaders
        const TextureLoader = new THREE.TextureLoader();
        const ObjectLoader = new GLTFLoader();

        //Caméra
        const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.25, 160);
        camera.position.set( 4, 5, 5 );
        camera.lookAt( 0, 0, 0 );
        scene.add( camera );


        //Lumière
        const light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 20, 20, 10 );
        light.castShadow = true;
        scene.add( light );

        const ambient = new THREE.AmbientLight( 0x404040, 3 ); // soft white light
        scene.add( ambient );


        //Fog
        const color = 0xFFFFFF;
        const density = 0.1;
        scene.fog = new THREE.FogExp2(color, density);


        //Sol
        const ground = new THREE.Mesh(
					new THREE.PlaneGeometry( 9, 9, 1, 1 ),
					new THREE.MeshPhongMaterial( { color: 0xa0adaf, shininess: 150 } )
				);
        ground.rotation.x = -Math.PI / 2
		ground.receiveShadow = true;
		scene.add( ground );


        //Cube
        const BoxGeometry = new THREE.BoxGeometry(1, 1, 1);
        const BoxTexture = TextureLoader.load( './default.png' );
        BoxTexture.colorSpace = THREE.SRGBColorSpace;
        const BoxMaterial = new THREE.MeshBasicMaterial({ map: BoxTexture, });
        
        const cube = new THREE.Mesh(BoxGeometry, BoxMaterial);
        cube.castShadow = true;
        scene.add(cube);
        cube.position.y = 0.5;


        //Phoque
        ObjectLoader.load('./bagel_seal.glb', function ( gltf ) {
            const model = gltf.scene;
            model.position.y = 1.23;
            model.rotation.y = 11*Math.PI/6;
            model.traverse( function ( object ) {
                if ( object.isMesh ) object.castShadow = true;
            } );
            scene.add( model );
        });

        //Renderer
        let renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.setAnimationLoop( animate );
		renderer.shadowMap.enabled = true;
		document.body.appendChild( renderer.domElement );


        //Controls Caméra
        const controls = new OrbitControls( camera, renderer.domElement );
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
		controls.target.set( 0, 1, 0 );

        controls.maxPolarAngle = Math.PI * 0.5;

        controls.rotateSpeed = 0.5;
        controls.panSpeed = 0.5; 
        
        controls.minDistance = 2;
        controls.maxDistance = 10;


        //DeviceEvent
        function isMobileLike() {
            // UA-CH first (Chrome/Edge modern)
            if (navigator.userAgentData && typeof navigator.userAgentData.mobile === "boolean") {
                return navigator.userAgentData.mobile;
            }
            // fallback on UA + iPadOS quirk + coarse pointer hint
            const ua = navigator.userAgent || "";
            if (/Mobi|Android|iPhone|iPad|iPod|Windows Phone|webOS|BlackBerry/i.test(ua)) return true;
            const isIPadOS = /Macintosh/i.test(ua) && navigator.maxTouchPoints > 1;
            if (isIPadOS) return true;
            if (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) return true;
            return false;
}

        function enableSensorsIfNeeded() {
            const need = typeof DeviceOrientationEvent !== "undefined"
                && typeof DeviceOrientationEvent.requestPermission === "function";
            if (!need) return;
            DeviceOrientationEvent.requestPermission().catch(()=>{});
            if (typeof DeviceMotionEvent !== "undefined"
                && typeof DeviceMotionEvent.requestPermission === "function") {
                DeviceMotionEvent.requestPermission().catch(()=>{});
            }
        }
        document.addEventListener("click", enableSensorsIfNeeded, { once: true });

        let alpha = 0, beta = 0, gamma = 0; // deg
        window.addEventListener("deviceorientation", (e) => {
            if (e.alpha == null) return;
            alpha = e.alpha; // yaw
            beta  = e.beta;  // pitch
            gamma = e.gamma; // roll
        }, true);

        const tmpEuler = new THREE.Euler(0, 0, 0, "YXZ");
        function applyOrientationTo(obj) {
            tmpEuler.set(
                THREE.MathUtils.degToRad(beta),
                THREE.MathUtils.degToRad(alpha),
                THREE.MathUtils.degToRad(-gamma),
                "YXZ"
            );
            obj.quaternion.setFromEuler(tmpEuler);
        }

        //Fonction d'animation
        function animate() {
            if (isMobileLike()) applyOrientationTo(mesh);
            renderer.render( scene, camera );
            controls.update();
        }
        renderer.setAnimationLoop( animate );
    </script>
  </body>
</html>